package kv

import (
	"context"
	"errors"
	"fmt"
	"github.com/tPhume/gokv/btree"
	"github.com/tPhume/gokv/store"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var keyDoesNotExist = errors.New("key does not exist")

// Will return standalone gRPC server
func DefaultGrpcServer() *grpc.Server {
	grpcServer := grpc.NewServer()
	RegisterGoKvServer(grpcServer, &GrpcServer{store: btree.NewBtree(3)})

	return grpcServer
}

// Create grpc with store as parameter
func GrpcWithStore(store store.Store) *grpc.Server {
	grpcServer := grpc.NewServer()
	RegisterGoKvServer(grpcServer, &GrpcServer{store: store})

	return grpcServer
}

// GrpcServer implements GoKv server which is generated by gRPC
type GrpcServer struct {
	store store.Store
}

func (g *GrpcServer) Insert(ctx context.Context, kv *KeyValue) (*Response, error) {
	if err := g.store.Insert(kv.Key.Key, kv.Value.Value); err != nil {
		return nil, status.Errorf(codes.Internal, err.Error())
	}

	return &Response{Message: fmt.Sprintf("key %v inserted", kv.Key.Key)}, nil
}

func (g *GrpcServer) Update(ctx context.Context, kv *KeyValue) (*Response, error) {
	if err := g.store.Update(kv.GetKey().GetKey(), kv.GetValue().GetValue()); err != nil {
		return nil, status.Errorf(codes.InvalidArgument, err.Error())
	}

	return &Response{Message: fmt.Sprintf("key %v updated", kv.Key.Key)}, nil
}

func (g *GrpcServer) Search(ctx context.Context, k *Key) (*Response, error) {
	val := g.store.Search(k.GetKey())
	if val == nil {
		return nil, status.Errorf(codes.InvalidArgument, keyDoesNotExist.Error())
	}

	value := &Value{Value: val}

	return &Response{
		Message: fmt.Sprintf("key %v found", k.GetKey()),
		Kv:      &KeyValue{Key: k, Value: value},
	}, nil
}

func (g *GrpcServer) Remove(ctx context.Context, k *Key) (*Response, error) {
	if err := g.store.Remove(k.GetKey()); err != nil {
		return nil, status.Errorf(codes.InvalidArgument, err.Error())
	}

	return &Response{Message: fmt.Sprintf("key %v deleted", k.GetKey())}, nil
}
